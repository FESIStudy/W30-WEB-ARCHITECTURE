## 1. 웹 아키텍처 개요

### 웹 서비스의 기본 동작 원리

- 웹 아키텍처의 기본 구조는 **클라이언트-서버 모델**을 기반으로 함
    - **클라이언트**: 사용자와 직접 상호작용하는 인터페이스 (브라우저, 앱 등)
    - **서버**: 데이터베이스 관리, 사용자 인증, 데이터 처리와 같은 백엔드 작업 담당
- **클라이언트-서버 모델**
    - 데이터와 리소스의 중앙 집중화 → 데이터 관리 및 보안 강화
    - 다양한 클라이언트 디바이스에서 서비스를 이용할 수 있음
    - 클라이언트와 서버가 분리되어 있어 각각 독립적으로 개발하고 업데이트할 수 있어 시스템의 확장성과 유지보수성을 크게 향상시킴

### HTTP/HTTPS 요청 처리

- 웹 통신의 핵심은 HTTP 프로토콜
- 클라이언트가 웹 서버에 요청을 보내면
    1. **URL 파싱**: 프로토콜(https://)과 호스트명(domain.com)으로 분리
    2. **DNS 조회**: 호스트명을 IP 주소로 변환
    3. **TCP 연결**: 3-way handshake를 통한 안정적인 연결 설정
    4. **SSL/TLS 핸드셰이크**: HTTPS의 경우 암호화 통신을 위한 인증서 확인 및 키 교환
    5. **HTTP 요청 전송**: GET, POST 등의 메서드로 실제 요청 전송
    6. **서버 응답**: 요청에 대한 처리 결과를 클라이언트에 반환
    
<br/>

## 2. 웹 서버(Web Server)

### 웹 서버란

- 클라이언트로부터 **HTTP 요청을 받아들이고**, 해당 요청에 대한 처리를 수행하여 클라이언트에게 **HTTP 응답을 전송하는 소프트웨어**
- 주요 기능: **정적 파일 처리, 동적 요청 중계**
- ex) Apache, Nginx

### 정적 파일 처리

- HTML, CSS, JS, 이미지 등의 정적 컨텐츠를 WAS를 거치지 않고 바로 클라이언트에 제공
    
    → 서버 부하를 크게 줄일 수 있음
    

### 리버스 프록시(Reverse Proxy)

- 요청을 대신 받아 내부 서버로 전달하고, 서버의 응답을 다시 클라이언트에게 전달하는 중간 서버
- 주요 기능: 로드 밸런싱, 캐싱, SSL 터미네이션, 보안 강화 등

### 대표 소프트웨어

- **Apache**
    - 전통적인 **Multi-Process Module** 방식 사용
    - 클라이언트 요청마다 프로세스나 스레드를 생성하는 구조로, 확장성 면에서 장점이 있지만 동시 연결 수가 증가하면 C10K문제가 발생할 수 있음
    - C10K 문제: 10,000개 이상의 동시 연결 시 성능 저하
- **Nginx**
    - 이벤트 기반의 **Master-Worker Process** 구조 사용
        - Master Process가 설정을 읽고 Worker Process를 생성, 각 Worker Process가 실제 요청을 처리
        - 적은 수의 프로세스로도 많은 동시 연결을 효율적으로 처리할 수 있어 현대적인 웹 서비스에 적합


> 빌드된 정적 파일(React, Vue 등)은 Nginx 같은 웹 서버에서 직접 서빙하는 경우가 많다.  
> CSR 앱도 HTML과 JS는 결국 웹 서버에서 내려온다.

<br/>

## 3. 애플리케이션 서버(WAS)

### WAS(Web Application Server)

- 동적인 웹 애플리케이션을 실행하는 역할 담당
- 웹 애플리케이션 로직을 실행하고, 데이터베이스와의 상호작용, 비즈니스 로직 처리, 트랜잭션 관리 등을 수행

### 동적 컨텐츠 처리

- 클라이언트의 요청에 따라 서버에서 동적으로 생성되는 페이지를 처리
- 데이터베이스 조회, 사용자 입력 처리, 외부 API 호출 등을 통해 **실시간으로 변화하는 컨텐츠를 제공**

### 대표 소프트웨어

- **Tomcat**
    - Java 기반의 대표적인 WAS로, 서블릿 컨테이너 역할 수행
    - 클라이언트 요청이 들어오면 Thread Pool에서 Thread를 할당하여 요청을 처리
    - Engine-Host-Context-Servlet 구조로 요청을 전달
- **Express, NestJS**
    - Node.js 생태계에서 주로 사용됨
    - Express: 높은 자유도로 빠른 개발이 가능하지만, 대규모 프로젝트에서는 구조가 복잡해질 수 있음
    - NestJS: Spring Boot와 유사한 구조로 TS 기반의 모듈화된 아키텍쳐 제공, 대규모 프로젝트에 적합
- **Spring Boot**
    - Java 기반의 엔터프라이즈급 애플리케이션 개발을 위한 프레임워크
    - 강력한 의존성 주입, 풍부한 생태계, 높은 안정성 제공

> 서버에서 SSR(Server Side Rendering)이 동작하면 WAS가 HTML까지 생성해 주는 것

<br/>

## 4. 웹 서버 vs WAS

### 기능적 차이

| **구분** | **웹 서버** | **WAS** |
| --- | --- | --- |
| **주요 역할** | 정적 컨텐츠 제공 | 동적 컨텐츠 처리 |
| **처리 대상** | HTML, CSS, JS, 이미지 | DB 연동, 비즈니스 로직 |
| **성능 특성** | 빠르고 안정적 | 상대적으로 무겁지만 유연함 |
| **확장성** | 수평 확장 용이 | 복잡한 확장 전략 필요 |

### 🤔 WAS가 웹 서버의 기능도 모두 수행하면 안 될까?

- **서버 부하 방지**: 정적 컨텐츠는 웹 서버에서, 동적 처리는 WAS에서 분담
- **보안 강화**: 물리적 분리를 통한 보안 계층 추가
- **무중단 운영**: 여러 WAS 인스턴스를 통한 로드 밸런싱으로 가용성 확보

> 즉, **자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성**을 위해 분리하는 것이 좋다.
> 

<br/>

## 5. 데이터베이스(DB)

### DB의 역할과 위치

- 웹 애플리케이션에서 모든 정보를 저장하고 관리하는 핵심 구성 요소
- 대부분의 모던 웹 애플리케이션은 하나 이상의 데이터베이스를 사용하여 정보를 저장

### RDB vs NoSQL

- **RDB** (관계형 데이터베이스)
    - 사전에 엄격하게 정의된 스키마를 요구하는 **테이블 기반 데이터 구조**를 가짐
    - 데이터 중복이 없기 때문에 업데이트가 많을 때 유리, 복잡한 쿼리와 트랜잭션 처리에 적합
- **NoSQL**
    - **비정형 데이터**를 저장할 수 있도록 지원
    - 스키마가 유연하여 빠른 개발과 확장에 유리하지만, 데이터 중복으로 인해 업데이트 시 모든 컬렉션에서 수정이 필요하므로 조회가 많고 업데이트가 적을 때 적합
- 선택 기준
    
    
    | **특성** | **RDB** | **NoSQL** |
    | --- | --- | --- |
    | **적합한 용도** | 금융, 정확한 데이터 무결성 요구 | 빅데이터, 실시간 웹 애플리케이션 |
    | **확장 방식** | 수직 확장 중심 | 수평 확장 중심 |
    | **일관성** | 강한 일관성 | 최종 일관성 |
    | **쿼리 복잡도** | 복잡한 조인 지원 | 단순한 쿼리에 최적화 |

<br/>

## 6. 고급 웹 아키텍처 요소

### CDN(Content Delivery Network)

- 지리적으로 분산된 여러 서버 네트워크로, **웹 콘텐츠를 사용자와 가까운 곳에서 전송**하여 전송 속도를 높임
- 구성 요소
    - **오리진 서버**: 콘텐츠의 원본을 저장하고 있는 서버
    - **엣지 서버**: 전 세계 여러 지점에 위치하여 캐싱된 콘텐츠를 제공하는 서버
    - **DNS 서버**: 사용자를 가장 적합한 엣지 서버로 라우팅하는 서버

### 로드밸런서(Load Balancer)

- 애플리케이션을 지원하는 리소스 풀 전체에 네트워크 트래픽을 균등하게 배포하는 시스템
- 주요 기능
    - **가용성 향상**: 서버 장애 시 자동으로 다른 서버로 트래픽 리다이렉션
    - **확장성 제공**: 필요에 따라 서버 추가/제거 가능
    - **성능 최적화**: 트래픽 병목 현상 방지

### 캐싱과 세션 관리

- **캐싱**: 자주 사용되는 데이터를 임시로 저장하여 동일한 요청에 대해 빠르게 응답하는 기술
    - 클라이언트 측 캐싱: 브라우저 캐싱, Service Worker
    - 서버 측 캐싱: Redis, Memcached를 활용한 메모리 캐싱
    - CDN 캐싱: 지리적으로 분산된 캐싱
    - 애플리케이션 캐싱: API 응답, 쿼리 결과 캐싱
- **세션 관리**: 사용자별 상태 정보를 유지하는 메커니즘
    - 로그인 정보, 장바구니 데이터, 사용자 설정 등을 저장
    - 분산 환경에서는 Redis와 같은 외부 저장소를 활용하여 세션 공유

### 확장성(Scalability)과 장애 대응(Failover)

- **수직 확장(Scale Up)**
    - 단일 서버의 성능을 향상시키는 방식
    - CPU, 메모리, 스토리지를 업그레이드
    - 구현이 간단하고 데이터 일관성 유지가 쉽지만, 확장 한계가 있고 단일 장애점(SPOF) 문제 존재
- **수평 확장(Scale Out)**
    - 여러 서버를 추가하여 부하를 분산시키는 방식
    - 이론적으로 무제한 확장이 가능하고 장애 격리가 가능하지만, 클러스터링 비용이 발생하며 관리가 복잡함
- 무중단 배포 전략
    - **롤링 배포**: 인스턴스를 순차적으로 교체
    - **블루-그린 배포**: 두 개의 환경을 유지하여 즉시 전환
    - **카나리 배포**: 일부 트래픽으로 먼저 테스트 후 점진적 확대
    
<br/>

## 7. 배포(Deployment)와 클라우드

### 정적 웹사이트 배포

- 정적 웹사이트: HTML, CSS, JS 파일로만 구성된 사이트 → 서버 측 처리가 불필요
- AWS S3, Github Pages, Netlify/Vercel 등으로 배포 가능

### 동적 서버 배포

- 전통적 서버 배포(EC2)
    - 가상 서버를 직접 관리하는 방식
    - Docker를 활용하면 애플리케이션과 의존성을 컨테이너로 패키징하여 일관된 환경에서 실행 가능
- Kubernetes
    - 컨테이너 오커스트레이션 플랫폼
    - 대규모 컨테이너 배포와 관리를 자동화
    - 자동 스케일링, 로드 밸런싱, 자가 치유 기능 제공
        - **자가 치유 기능**: 컨테이너가 죽거나 장애가 발생하면 쿠버네티스가 이를 자동으로 감지하고, Desired State와 Current State를 비교하여 자동으로 컨테이너를 재시작하거나 다른 노드에 새로 배치해줌. 즉, 사람이 서버에 SSH로 들어가서 `docker restart` 같은 명령을 칠 필요가 없어진다는 뜻

### 서버리스 아키텍쳐

- 서버리스
    - 서버가 없다 X, **서버는 존재하지만 서버를 직접 운영하거나 관리하지 않아도 된다 O**
    - 코드 단위로 배포하고, 사용량에 따라 자동 확장됨
        - ex) AWS Lambda, Vercel, Netlify, Cloudflare Workers
        - 서버 OS 관리, 서버 증설, 트래픽 모니터링 등을 클라우드 서비스가 대신해줌
    - 이벤트 기반으로 동작
        - 요청이 올 때만 코드가 실행되고, 없을 땐 자원이 할당되지 않아 비용 절감 가능
    - 장점
        - 트래픽이 적으면 비용 절감
        - 자동 스케일링
        - 빠른 배포, 인프라 관리 부담 감소
    - 단점
        - Cold Start (처음 호출 시 지연 발생 가능)
        - 장시간 연결(WebSocket 등)에 부적합
        - 특정 클라우드 서비스(Vercel, Lambda 등)에 종속될 수 있음
- Serverless Framework
    - 서버리스 애플리케이션의 구축, 배포, 관리를 단순화하는 도구
    - YAML 설정 파일을 통해 AWS Lambda, API Gateway 등을 쉽게 구성하고 배포할 수 있음
    - 서버 관리가 불필요하므로 운영 비용을 절감할 수 있고, 인프라보다 비즈니스 로직에 집중할 수 있어 개발 생산성이 높아지는 장점이 있음

### CI/CD

- **CI (Continuous Integration, 지속적 통합)**
    - 개발자가 코드를 메인 브랜치에 통합하는 프로세스
    - 핵심 목표
        - 변경 사항을 빠르게 검증 → 버그를 조기에 발견
        - 코드 품질 유지 → 테스트 자동화
        - 충돌 최소화 → 작은 단위로 병합
    - CI 파이프라인의 일반적인 흐름
        1. 코드 푸시 (GitHub, GitLab, Bitbucket 등)
        2. 빌드(Build) → 의존성 설치, 소스 코드 컴파일
        3. 테스트(Test) → 단위 테스트, 통합 테스트 자동 실행
        4. 정적 분석(Lint, Type Check) → 코드 스타일 및 타입 오류 검사
        5. 결과 피드백 → 실패 시 빌드 중단, 성공 시 병합 가능
    - 도구: Github Actions, GitLab CI/CD, CircleCI, Jenkins 등
- **CD (Continuous Delivery/Deployment, 지속적 제공/배포)**
    - Continuous Delivery (지속적 제공)
        - 빌드/테스트가 통과된 코드를 자동으로 스테이징 환경에 배포
        - 운영 배포는 수동 승인 (버튼 한 번 클릭)
    - Continuous Deployment (지속적 배포)
        - 테스트 통과 시 운영 환경까지 자동 배포
        - 사람 개입 없이 최신 코드가 항상 배포됨
    - CD 파이프라인의 일반적인 흐름
        1. CI 완료 → 배포 준비된 아티팩트 생성 (Docker 이미지, 빌드 파일)
        2. 스테이징 배포 → QA 테스트 → 승인(Delivery)
        3. 운영 배포 (Deployment)
        4. 배포 후 모니터링 → 오류 발생 시 롤백
    - 도구: AWS CodePipeline, ArgoCD(Kubernetes), GitHub Actions + AWS CLI, Vercel/Netlify(자동 배포)
- 웹 아키텍처에서의 CI/CD 적용 예시
    - 프론트엔드
        - PR 생성 → Lint/Type 체크 → 빌드 → E2E 테스트 → Vercel/Netlify 자동 배포 (Preview URL 제공) → 병합 시 Production 자동 배포
    - 백엔드
        - PR 생성 → Unit Test → Docker 빌드 → AWS ECR에 이미지 업로드 → AWS ECS/EKS 또는 Lambda에 자동 반영
    - 하이브리드(모노레포)
        - Turborepo/Nx 같은 빌드 툴로 프로젝트 단위 테스트 및 빌드
        - 프론트는 Vercel에, 백엔드는 Lambda에, DB 마이그레이션은 RDS에 자동 적용

<br/>

## 8. 실제 서비스 아키텍처 예시

- 소규모 스타트업 구조 (EC2 + Nginx + DB)
    
    ```tsx
    사용자 → Nginx (웹 서버) → Node.js/Express (WAS) → PostgreSQL (DB)
                  ↓
             정적 파일 서빙
    ```
    
- 대규모 서비스 구조 (CDN + 로드밸런서 + 웹 서버 + WAS + DB 클러스터)
    
    ```tsx
    사용자 → CDN → 로드 밸런서 → 웹 서버 클러스터 → WAS 클러스터 → DB 클러스터
                                    ↓              ↓             ↓
                                정적 컨텐츠      동적 처리     Master/Slave
                                                              + 캐시 서버
    ```
    
    - DB 클러스터의 Master/Slave 구조
        - Master DB: **쓰기** 작업을 답당하는 메인 데이터베이스
        - Slave DB: Master DB의 데이터를 복제하여 **읽기** 작업을 담당
    - 실제 동작 예시
        1. **사용자**: "상품 목록을 보여줘"
        2. **CDN**: 상품 이미지들을 가까운 서버에서 빠르게 제공
        3. **로드 밸런서**: 동적 데이터 요청을 적절한 웹 서버로 분배
        4. **웹 서버**: 정적인 HTML 틀을 제공
        5. **WAS**: 상품 목록 조회 로직 실행
        6. **캐시 서버**: 먼저 캐시에 상품 목록이 있는지 확인
        7. **Slave DB**: 캐시에 없다면 데이터베이스에서 상품 목록 조회
        8. **응답**: 역순으로 데이터가 사용자에게 전달
- 현대적 클라우드 아키텍처 (Serverless, FaaS, PaaS)
    
    ```tsx
    사용자 → CDN (정적 리소스) → API Gateway → Lambda(FaaS) → DB (Managed)
                     ↓                           ↓
               정적 파일 호스팅           캐시/스토리지(S3, Redis)
    ```
    
    - 동작 예시
        1. **사용자**: 브라우저가 웹사이트 접속
        2. **CDN**: 정적 리소스(JS, CSS, 이미지)는 CDN에서 즉시 제공
        3. **API Gateway**: 데이터 요청(API 호출)이 들어오면 Lambda로 전달
        4. **Lambda(FaaS)**: 필요한 로직을 실행 → DB/캐시에서 데이터 조회
        5. **DB (Managed Service)**: 요청 데이터를 반환
        6. **Lambda** → **API Gateway** → **사용자 브라우저**로 응답
- 🤔 그럼 서버리스로 많이 넘어가는 추세인가?
    - 추세인 건 맞으나, 한계가 명확하기 때문에 100& 넘어가는 건 아니다.
    - 스타트업, 소규모 프로젝트, 프론트엔드 중심 서비스는 서버리스 선호
    - 대규모 트래픽, 장시간 연결 서비스는 전통적인 구조 사용
    - **앞으로는 여러 개의 구조를 혼합한 하이브리드 아키텍처가 일반적인 구조가 될 가능성이 높다.**

<br/>

### 참고

- https://vfunction.com/blog/3-tier-application/
- https://blog.runners.im/serverless-framework%EB%A1%9C-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%89%BD%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-%EC%84%A4%EC%B9%98%EB%B6%80%ED%84%B0-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94%EA%B9%8C%EC%A7%80-with-lambda-api-gateway-of-aws-fa01e1f6ccf6
- https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html