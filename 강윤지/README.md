## 1. 웹 아키텍처 개요

- 만약, 브라우저에서 구글(https://google.com)에 접속한다면 웹 애플리케이션은 다음과 같은 순서로 진행하게 된다
    1. 브라우저에 구글 주소를 입력하여 접속한다.
    2. 브라우저는 URL을 입력받으면, 서버의 주소를 찾기 위해 DNS 서버에 요청을 보낸다.
    3. DNS 서버에서 IP주소를 찾으면 해당 주소에 HTTPS 요청을 보낸다. (만약, 이미 방문 기록이 캐시 메모리에 있으면 IP 주소를 캐시 메모리에서 가져온다.)
    4. 웹서버에 요청이 도착하여 웹 서버는 데이터베이스에 요청을 보내 페이지 관련 데이터들을 가져온다.
    5. 정보들을 가져오는 과정에서 비즈니스 로직이 작동한다.
    6. 로직들을 통해 요청받은 데이터들이 처리되고 브라우저에 응답한다.
    7. 요청들이 브라우저에 응답으로 돌아왔을 때, 웹 페이지 화면에 출력한다.
- 여기서 클라이언트와 서버, DB에 대한 개념을 잡고 넘어가자
    - **클라이언트(Client)**: 사용자가 직접 사용하는 프로그램(웹 브라우저, 앱 등)
    - **서버(Server)**: 요청을 받아 처리하고, 결과(Response)를 돌려주는 역할
    - **DB**: 데이터를 저장하고 제공하는 시스템

## 2. DNS 작동 원리

- DNS란?
    - 사람이 기억하기 쉬운 도메인 이름을 IP 주소로 바꿔주는 분산형 전화번호부(?)
    - 브라우저가 https://www.example.com에 접속하려면 먼저 IP 주소를 알아야 하고, 이 IP를 얻는 과정이 DNS 조회이다.
- 전체 흐름
    
    아래는 사용자가 `www.example.com`에 접속하는 순간 일어나는 **단계별 흐름**이다.
    
    1. **브라우저 캐시 조회**
        - 과거에 같은 이름을 조회했다면 TTL 안에서 재사용
    2. **OS/호스트 파일/로컬 캐시**
        - `/etc/hosts`(macOS/Linux) 혹은 시스템 DNS 캐시 확인
    3. **리졸버(Resolver)로 질의**
        - 보통 ISP(또는 8.8.8.8, 1.1.1.1 같은 공용)의 **재귀 리졸버(Recursive Resolver)** 에게 묻는다
    4. **재귀 리졸버의 동작** *(필요할 때만)*
        - **루트 네임서버** → **TLD(.com 등) 네임서버** → **권한 있는(Authoritative) 네임서버** 순으로 **위임(Delegation)** 을 따라가며 IP를 찾아온다
    5. **응답 & 캐싱**
        - 찾은 결과를 TTL 동안 **리졸버/OS/브라우저** 각 레벨에서 캐싱
    6. **연결 시작**
        - IP를 알았으니 이제 TCP(또는 QUIC) 연결 → HTTP(S) 요청
    
    > 핵심: 대부분의 트래픽은 캐시 덕분에 루트/TLD까지 안 가고 리졸버에서 바로 응답된다.
    > 

## 3. 웹 서버

- 정의와 역할
    - 웹서버는 클라이언트(=브라우저)로부터 들어오는 HTTP 요청을 받아 정적 리소스(HTML,CSS, JS, 이미지 등)를 응답하는 소프트웨어 또는 하드웨어를 의미. 즉, 요청이 들어왔을 때 파일을 그대로 제공하는 역할
- 정적 파일 처리
    - 브라우저가 /index.html 요청 → 웹 서버는 index.html 파일 그대로 반환
    - CSS, JS, 이미지 요청도 동일
    - 렌더링이나 데이터 가공 없이 그대로 전달하는 것이 특징
- 대표 소프트웨어
    - **Apache HTTP Server**
        - 가장 오래되고 안정적인 오픈소스 웹 서버
        - 모듈 기반 확장 가능 (PHP, SSL 등)
    - **Nginx**
        - 고성능, 비동기 이벤트 기반
        - 정적 파일 처리 및 리버스 프록시에 강점
        - 대규모 서비스에서 많이 사용
- 리버스 프록시(Reverse Proxy)
    - 웹 서버는 단순히 정적 파일만 제공하는게 아니라, WAS 앞단에서 트래픽을 중계하는 역할도 한다. = 리버스 프록시
        - 클라이언트는 웹 서버와만 통신 (WAS는 직접 노출되지 않음)
        - 웹 서버가 요청을 받아 적절한 WAS나 다른 서버로 전달
        - 보안, 부하 분산, 캐싱에 유리
    
    ```css
    [브라우저] → [Nginx(리버스 프록시)] → [WAS 서버] → [DB]
    ```
    

## 4. 애플리케이션 서버(WAS)

- 정의와 역할
    - WAS(Web Application Server)는 웹 애플리케이션 로직을 실행하는 서버이다.
    - 정적인 파일 제공이 아니라, 동적인 요청(로그인, 검색, 주문 등)을 처리하는데 특화
- 동적 콘텐츠 처리
    - 사용자가 로그인 폼 제출 → WAS가 DB와 연동하여 사용자 정보 확인
    - 사용자가 상품 검색 → DB에서 검색 결과 조회 후 HTML에 반영
    - 사용자가 주문 → DB에 주문 기록 저장 + 결제 프로세스 실행
    
    ⇒ 즉, WAS는 **프로그래밍 언어 기반의 서버 코드**가 동작하는 곳
    
- 대표 소프트웨어
    - **Java 진영**
        - Tomcat (가장 대표적인 오픈소스 WAS)
        - Spring Boot (내장 Tomcat, Jetty 활용)
    - **JavaScript 진영**
        - Node.js (비동기 이벤트 기반, Express/NestJS 프레임워크와 함께 사용)
    - **기타**
        - JBoss, WebSphere, WebLogic 등 (대규모 엔터프라이즈 환경)
- 웹 서버와의 협력 구조
    - **웹 서버**: 정적 리소스 빠른 제공
    - **WAS**: 동적 로직 처리

```scss
[브라우저] 
   ↓ 
[웹 서버(Nginx, 정적 파일 처리)] 
   ↓ (동적 요청 전달)
[WAS(Tomcat, Node.js, Spring Boot)] 
   ↓ 
[DB 서버(MySQL, MongoDB)]
```

## 5. 웹 서버 vs WAS 비교

| 구분 | 웹 서버(Web Server) | WAS(Web Application Server) |
| --- | --- | --- |
| 주요 역할 | 정적 콘텐츠 제공 | 동적 콘텐츠 처리 |
| 처리 대상 | HTML, CSS, JS, 이미지 | 로그인, 결제, 게시글 CRUD |
| 대표 예시 | Apache, Nginx | Tomcat, Node.js, Spring Boot |
| 장점 | 빠른 속도, 가벼움 | 복잡한 로직 수행 가능 |
| 단점 | 동적 처리 불가 | 정적 파일 처리에 비효율적 |
- 실제 서비스에서의 배치 방식
    - 소규모 서비스: 웹 서버 + WAS 통합(Node.js 단일 서버)
    - 중대형 서비스: 웹 서버와 WAS 분리
        - 웹 서버: 정적 파일 캐싱 + 리버스 프록시
        - WAS: 오직 비즈니스 로직 처리
- 단일 서버 구조 vs 분리된 서버 구조
    - **단일 서버 구조**
        - 웹 서버와 WAS 역할을 하나의 프로그램/서버가 처리
        - 빠르게 개발 가능, 초기 스타트업에 적합
        - 예: Node.js Express 앱에서 정적 파일과 API 둘 다 처리
    - **분리된 서버 구조**
        - 웹 서버: 정적 리소스 제공 + 프록시
        - WAS: 동적 로직 집중
        - 확장성, 성능, 보안에 유리
        - 예: Nginx + Spring Boot + MySQL 구조

## 6. 데이터베이스(DB)

- 역할과 위치
    - DB는 **데이터 저장소**
    - 회원 정보, 게시글, 결제 내역 등 모든 서비스의 핵심 데이터를 관리
    - WAS가 DB와 통신하여 CRUD 수행
- RDB vs NoSQL
    - **RDB(Relational Database)**
        - MySQL, PostgreSQL, Oracle
        - 테이블 기반, SQL 사용
        - 데이터 무결성, 트랜잭션 보장
    - **NoSQL**
        - MongoDB, Redis, Cassandra
        - 문서/키-값 기반
        - 대규모 분산 시스템, 빠른 읽기/쓰기
- WAS ↔ DB 연결 과정
    1. 사용자가 로그인 시도
    2. WAS가 DB에 `SELECT * FROM users WHERE email=?` 쿼리 전송
    3. DB가 결과 반환
    4. WAS가 응답 데이터를 가공 → 브라우저에 전달

정리하자면,

- **웹 서버**: 정적 파일 처리
- **WAS**: 동적 로직 처리
- **DB**: 데이터 제공

---

참고

https://kschoi.github.io/cs/the-basic-archtecture-concepts/

https://ittrue.tistory.com/189

[https://bokjiho.medium.com/웹-아키텍처의-구성-요소와-구조-694e994f798](https://bokjiho.medium.com/%EC%9B%B9-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C%EC%99%80-%EA%B5%AC%EC%A1%B0-694e994f798)

https://seonghui.github.io/TIL/docs/etc/web-architecture.html
